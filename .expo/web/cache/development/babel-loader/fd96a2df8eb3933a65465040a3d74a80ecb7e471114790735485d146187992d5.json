{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _excluded = [\"origin\", \"waypoints\", \"splitWaypoints\", \"destination\", \"apikey\", \"onReady\", \"onError\", \"mode\", \"language\", \"region\", \"precision\"];\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Polyline } from 'react-native-maps';\nimport isEqual from 'lodash.isequal';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar WAYPOINT_LIMIT = 10;\nvar MapViewDirections = function (_Component) {\n  _inherits(MapViewDirections, _Component);\n  var _super = _createSuper(MapViewDirections);\n  function MapViewDirections(_props) {\n    var _this;\n    _classCallCheck(this, MapViewDirections);\n    _this = _super.call(this, _props);\n    _this.resetState = function () {\n      var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      _this.setState({\n        coordinates: null,\n        distance: null,\n        duration: null\n      }, cb);\n    };\n    _this.fetchAndRenderRoute = function (props) {\n      var initialOrigin = props.origin,\n        initialDestination = props.destination,\n        _props$waypoints = props.waypoints,\n        initialWaypoints = _props$waypoints === void 0 ? [] : _props$waypoints,\n        apikey = props.apikey,\n        onStart = props.onStart,\n        onReady = props.onReady,\n        onError = props.onError,\n        _props$mode = props.mode,\n        mode = _props$mode === void 0 ? 'DRIVING' : _props$mode,\n        _props$language = props.language,\n        language = _props$language === void 0 ? 'en' : _props$language,\n        optimizeWaypoints = props.optimizeWaypoints,\n        splitWaypoints = props.splitWaypoints,\n        _props$directionsServ = props.directionsServiceBaseUrl,\n        directionsServiceBaseUrl = _props$directionsServ === void 0 ? 'https://maps.googleapis.com/maps/api/directions/json' : _props$directionsServ,\n        region = props.region,\n        _props$precision = props.precision,\n        precision = _props$precision === void 0 ? 'low' : _props$precision,\n        _props$timePrecision = props.timePrecision,\n        timePrecision = _props$timePrecision === void 0 ? 'none' : _props$timePrecision,\n        channel = props.channel;\n      if (!apikey) {\n        console.warn(`MapViewDirections Error: Missing API Key`);\n        return;\n      }\n      if (!initialOrigin || !initialDestination) {\n        return;\n      }\n      var timePrecisionString = timePrecision === 'none' ? '' : timePrecision;\n      var routes = [];\n      if (splitWaypoints && initialWaypoints && initialWaypoints.length > WAYPOINT_LIMIT) {\n        var chunckedWaypoints = initialWaypoints.reduce(function (accumulator, waypoint, index) {\n          var numChunk = Math.floor(index / WAYPOINT_LIMIT);\n          accumulator[numChunk] = [].concat(accumulator[numChunk] || [], waypoint);\n          return accumulator;\n        }, []);\n        for (var i = 0; i < chunckedWaypoints.length; i++) {\n          routes.push({\n            waypoints: chunckedWaypoints[i],\n            origin: i === 0 ? initialOrigin : chunckedWaypoints[i - 1][chunckedWaypoints[i - 1].length - 1],\n            destination: i === chunckedWaypoints.length - 1 ? initialDestination : chunckedWaypoints[i + 1][0]\n          });\n        }\n      } else {\n        routes.push({\n          waypoints: initialWaypoints,\n          origin: initialOrigin,\n          destination: initialDestination\n        });\n      }\n      Promise.all(routes.map(function (route, index) {\n        var origin = route.origin,\n          destination = route.destination,\n          waypoints = route.waypoints;\n        if (origin.latitude && origin.longitude) {\n          origin = `${origin.latitude},${origin.longitude}`;\n        }\n        if (destination.latitude && destination.longitude) {\n          destination = `${destination.latitude},${destination.longitude}`;\n        }\n        waypoints = waypoints.map(function (waypoint) {\n          return waypoint.latitude && waypoint.longitude ? `${waypoint.latitude},${waypoint.longitude}` : waypoint;\n        }).join('|');\n        if (optimizeWaypoints) {\n          waypoints = `optimize:true|${waypoints}`;\n        }\n        if (index === 0) {\n          onStart && onStart({\n            origin: origin,\n            destination: destination,\n            waypoints: initialWaypoints\n          });\n        }\n        return _this.fetchRoute(directionsServiceBaseUrl, origin, waypoints, destination, apikey, mode, language, region, precision, timePrecisionString, channel).then(function (result) {\n          return result;\n        }).catch(function (errorMessage) {\n          return Promise.reject(errorMessage);\n        });\n      })).then(function (results) {\n        var result = results.reduce(function (acc, _ref) {\n          var distance = _ref.distance,\n            duration = _ref.duration,\n            coordinates = _ref.coordinates,\n            fare = _ref.fare,\n            legs = _ref.legs,\n            waypointOrder = _ref.waypointOrder;\n          acc.coordinates = [].concat(_toConsumableArray(acc.coordinates), _toConsumableArray(coordinates));\n          acc.distance += distance;\n          acc.duration += duration;\n          acc.fares = [].concat(_toConsumableArray(acc.fares), [fare]);\n          acc.legs = legs;\n          acc.waypointOrder = [].concat(_toConsumableArray(acc.waypointOrder), [waypointOrder]);\n          return acc;\n        }, {\n          coordinates: [],\n          distance: 0,\n          duration: 0,\n          fares: [],\n          legs: [],\n          waypointOrder: []\n        });\n        _this.setState({\n          coordinates: result.coordinates\n        }, function () {\n          if (onReady) {\n            onReady(result);\n          }\n        });\n      }).catch(function (errorMessage) {\n        _this.resetState();\n        console.warn(`MapViewDirections Error: ${errorMessage}`);\n        onError && onError(errorMessage);\n      });\n    };\n    _this.state = {\n      coordinates: null,\n      distance: null,\n      duration: null\n    };\n    return _this;\n  }\n  _createClass(MapViewDirections, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.fetchAndRenderRoute(this.props);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this2 = this;\n      if (!isEqual(prevProps.origin, this.props.origin) || !isEqual(prevProps.destination, this.props.destination) || !isEqual(prevProps.waypoints, this.props.waypoints) || !isEqual(prevProps.mode, this.props.mode) || !isEqual(prevProps.precision, this.props.precision) || !isEqual(prevProps.splitWaypoints, this.props.splitWaypoints)) {\n        if (this.props.resetOnChange === false) {\n          this.fetchAndRenderRoute(this.props);\n        } else {\n          this.resetState(function () {\n            _this2.fetchAndRenderRoute(_this2.props);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(t) {\n      var points = [];\n      for (var step of t) {\n        var encoded = step.polyline.points;\n        var index = 0,\n          len = encoded.length;\n        var lat = 0,\n          lng = 0;\n        while (index < len) {\n          var b = void 0,\n            shift = 0,\n            result = 0;\n          do {\n            b = encoded.charAt(index++).charCodeAt(0) - 63;\n            result |= (b & 0x1f) << shift;\n            shift += 5;\n          } while (b >= 0x20);\n          var dlat = (result & 1) != 0 ? ~(result >> 1) : result >> 1;\n          lat += dlat;\n          shift = 0;\n          result = 0;\n          do {\n            b = encoded.charAt(index++).charCodeAt(0) - 63;\n            result |= (b & 0x1f) << shift;\n            shift += 5;\n          } while (b >= 0x20);\n          var dlng = (result & 1) != 0 ? ~(result >> 1) : result >> 1;\n          lng += dlng;\n          points.push({\n            latitude: lat / 1E5,\n            longitude: lng / 1E5\n          });\n        }\n      }\n      return points;\n    }\n  }, {\n    key: \"fetchRoute\",\n    value: function fetchRoute(directionsServiceBaseUrl, origin, waypoints, destination, apikey, mode, language, region, precision, timePrecision, channel) {\n      var _this3 = this;\n      var url = directionsServiceBaseUrl;\n      if (typeof directionsServiceBaseUrl === 'string') {\n        url += `?origin=${origin}&waypoints=${waypoints}&destination=${destination}&key=${apikey}&mode=${mode.toLowerCase()}&language=${language}&region=${region}`;\n        if (timePrecision) {\n          url += `&departure_time=${timePrecision}`;\n        }\n        if (channel) {\n          url += `&channel=${channel}`;\n        }\n      }\n      return fetch(url).then(function (response) {\n        return response.json();\n      }).then(function (json) {\n        if (json.status !== 'OK') {\n          var errorMessage = json.error_message || json.status || 'Unknown error';\n          return Promise.reject(errorMessage);\n        }\n        if (json.routes.length) {\n          var route = json.routes[0];\n          return Promise.resolve({\n            distance: route.legs.reduce(function (carry, curr) {\n              return carry + curr.distance.value;\n            }, 0) / 1000,\n            duration: route.legs.reduce(function (carry, curr) {\n              return carry + (curr.duration_in_traffic ? curr.duration_in_traffic.value : curr.duration.value);\n            }, 0) / 60,\n            coordinates: precision === 'low' ? _this3.decode([{\n              polyline: route.overview_polyline\n            }]) : route.legs.reduce(function (carry, curr) {\n              return [].concat(_toConsumableArray(carry), _toConsumableArray(_this3.decode(curr.steps)));\n            }, []),\n            fare: route.fare,\n            waypointOrder: route.waypoint_order,\n            legs: route.legs\n          });\n        } else {\n          return Promise.reject();\n        }\n      }).catch(function (err) {\n        return Promise.reject(`Error on GMAPS route request: ${err}`);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var coordinates = this.state.coordinates;\n      if (!coordinates) {\n        return null;\n      }\n      var _this$props = this.props,\n        origin = _this$props.origin,\n        waypoints = _this$props.waypoints,\n        splitWaypoints = _this$props.splitWaypoints,\n        destination = _this$props.destination,\n        apikey = _this$props.apikey,\n        onReady = _this$props.onReady,\n        onError = _this$props.onError,\n        mode = _this$props.mode,\n        language = _this$props.language,\n        region = _this$props.region,\n        precision = _this$props.precision,\n        props = _objectWithoutProperties(_this$props, _excluded);\n      return _jsx(Polyline, _objectSpread({\n        coordinates: coordinates\n      }, props));\n    }\n  }]);\n  return MapViewDirections;\n}(Component);\nMapViewDirections.propTypes = {\n  origin: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    latitude: PropTypes.number.isRequired,\n    longitude: PropTypes.number.isRequired\n  })]),\n  waypoints: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    latitude: PropTypes.number.isRequired,\n    longitude: PropTypes.number.isRequired\n  })])),\n  destination: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    latitude: PropTypes.number.isRequired,\n    longitude: PropTypes.number.isRequired\n  })]),\n  apikey: PropTypes.string.isRequired,\n  onStart: PropTypes.func,\n  onReady: PropTypes.func,\n  onError: PropTypes.func,\n  mode: PropTypes.oneOf(['DRIVING', 'BICYCLING', 'TRANSIT', 'WALKING']),\n  language: PropTypes.string,\n  resetOnChange: PropTypes.bool,\n  optimizeWaypoints: PropTypes.bool,\n  splitWaypoints: PropTypes.bool,\n  directionsServiceBaseUrl: PropTypes.string,\n  region: PropTypes.string,\n  precision: PropTypes.oneOf(['high', 'low']),\n  timePrecision: PropTypes.oneOf(['now', 'none']),\n  channel: PropTypes.string\n};\nexport default MapViewDirections;","map":{"version":3,"names":["React","Component","PropTypes","Polyline","isEqual","jsx","_jsx","WAYPOINT_LIMIT","MapViewDirections","_Component","_inherits","_super","_createSuper","props","_this","_classCallCheck","call","resetState","cb","arguments","length","undefined","setState","coordinates","distance","duration","fetchAndRenderRoute","initialOrigin","origin","initialDestination","destination","_props$waypoints","waypoints","initialWaypoints","apikey","onStart","onReady","onError","_props$mode","mode","_props$language","language","optimizeWaypoints","splitWaypoints","_props$directionsServ","directionsServiceBaseUrl","region","_props$precision","precision","_props$timePrecision","timePrecision","channel","console","warn","timePrecisionString","routes","chunckedWaypoints","reduce","accumulator","waypoint","index","numChunk","Math","floor","concat","i","push","Promise","all","map","route","latitude","longitude","join","fetchRoute","then","result","catch","errorMessage","reject","results","acc","_ref","fare","legs","waypointOrder","_toConsumableArray","fares","state","_createClass","key","value","componentDidMount","componentDidUpdate","prevProps","_this2","resetOnChange","decode","t","points","step","encoded","polyline","len","lat","lng","b","shift","charAt","charCodeAt","dlat","dlng","_this3","url","toLowerCase","fetch","response","json","status","error_message","resolve","carry","curr","duration_in_traffic","overview_polyline","steps","waypoint_order","err","render","_this$props","_objectWithoutProperties","_excluded","_objectSpread","propTypes","oneOfType","string","shape","number","isRequired","arrayOf","func","oneOf","bool"],"sources":["C:/Users/victo/Desktop/rotas-tcc/node_modules/react-native-maps-directions/src/MapViewDirections.js"],"sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Polyline } from 'react-native-maps';\nimport isEqual from 'lodash.isequal';\n\nconst WAYPOINT_LIMIT = 10;\n\nclass MapViewDirections extends Component {\n\n\tconstructor(props) {\n\t\tsuper(props);\n\n\t\tthis.state = {\n\t\t\tcoordinates: null,\n\t\t\tdistance: null,\n\t\t\tduration: null,\n\t\t};\n\t}\n\n\tcomponentDidMount() {\n\t\tthis.fetchAndRenderRoute(this.props);\n\t}\n\n\tcomponentDidUpdate(prevProps) {\n\t\tif (!isEqual(prevProps.origin, this.props.origin) || !isEqual(prevProps.destination, this.props.destination) || !isEqual(prevProps.waypoints, this.props.waypoints) || !isEqual(prevProps.mode, this.props.mode) || !isEqual(prevProps.precision, this.props.precision) || !isEqual(prevProps.splitWaypoints, this.props.splitWaypoints)) {\n\t\t\tif (this.props.resetOnChange === false) {\n\t\t\t\tthis.fetchAndRenderRoute(this.props);\n\t\t\t} else {\n\t\t\t\tthis.resetState(() => {\n\t\t\t\t\tthis.fetchAndRenderRoute(this.props);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tresetState = (cb = null) => {\n\t\tthis.setState({\n\t\t\tcoordinates: null,\n\t\t\tdistance: null,\n\t\t\tduration: null,\n\t\t}, cb);\n\t}\n\n\tdecode(t) {\n\t\tlet points = [];\n\t\tfor (let step of t) {\n\t\t\tlet encoded = step.polyline.points;\n\t\t\tlet index = 0, len = encoded.length;\n\t\t\tlet lat = 0, lng = 0;\n\t\t\twhile (index < len) {\n\t\t\t\tlet b, shift = 0, result = 0;\n\t\t\t\tdo {\n\t\t\t\t\tb = encoded.charAt(index++).charCodeAt(0) - 63;\n\t\t\t\t\tresult |= (b & 0x1f) << shift;\n\t\t\t\t\tshift += 5;\n\t\t\t\t} while (b >= 0x20);\n\n\t\t\t\tlet dlat = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));\n\t\t\t\tlat += dlat;\n\t\t\t\tshift = 0;\n\t\t\t\tresult = 0;\n\t\t\t\tdo {\n\t\t\t\t\tb = encoded.charAt(index++).charCodeAt(0) - 63;\n\t\t\t\t\tresult |= (b & 0x1f) << shift;\n\t\t\t\t\tshift += 5;\n\t\t\t\t} while (b >= 0x20);\n\t\t\t\tlet dlng = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));\n\t\t\t\tlng += dlng;\n\n\t\t\t\tpoints.push({ latitude: (lat / 1E5), longitude: (lng / 1E5) });\n\t\t\t}\n\t\t}\n\t\treturn points;\n\t}\n\n\tfetchAndRenderRoute = (props) => {\n\n\t\tlet {\n\t\t\torigin: initialOrigin,\n\t\t\tdestination: initialDestination,\n\t\t\twaypoints: initialWaypoints = [],\n\t\t\tapikey,\n\t\t\tonStart,\n\t\t\tonReady,\n\t\t\tonError,\n\t\t\tmode = 'DRIVING',\n\t\t\tlanguage = 'en',\n\t\t\toptimizeWaypoints,\n\t\t\tsplitWaypoints,\n\t\t\tdirectionsServiceBaseUrl = 'https://maps.googleapis.com/maps/api/directions/json',\n\t\t\tregion,\n\t\t\tprecision = 'low',\n\t\t\ttimePrecision = 'none',\n\t\t\tchannel,\n\t\t} = props;\n\n\t\tif (!apikey) {\n\t\t\tconsole.warn(`MapViewDirections Error: Missing API Key`); // eslint-disable-line no-console\n\t\t\treturn;\n\t\t}\n\n\t\tif (!initialOrigin || !initialDestination) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst timePrecisionString = timePrecision==='none' ? '' : timePrecision;\n\t\t\n\t\t// Routes array which we'll be filling.\n\t\t// We'll perform a Directions API Request for reach route\n\t\tconst routes = [];\n\n\t\t// We need to split the waypoints in chunks, in order to not exceede the max waypoint limit\n\t\t// ~> Chunk up the waypoints, yielding multiple routes\n\t\tif (splitWaypoints && initialWaypoints && initialWaypoints.length > WAYPOINT_LIMIT) {\n\t\t\t// Split up waypoints in chunks with chunksize WAYPOINT_LIMIT\n\t\t\tconst chunckedWaypoints = initialWaypoints.reduce((accumulator, waypoint, index) => {\n\t\t\t\tconst numChunk = Math.floor(index / WAYPOINT_LIMIT); \n\t\t\t\taccumulator[numChunk] = [].concat((accumulator[numChunk] || []), waypoint); \n\t\t\t\treturn accumulator;\n\t\t\t}, []);\n\n\t\t\t// Create routes for each chunk, using:\n\t\t\t// - Endpoints of previous chunks as startpoints for the route (except for the first chunk, which uses initialOrigin)\n\t\t\t// - Startpoints of next chunks as endpoints for the route (except for the last chunk, which uses initialDestination)\n\t\t\tfor (let i = 0; i < chunckedWaypoints.length; i++) {\n\t\t\t\troutes.push({\n\t\t\t\t\twaypoints: chunckedWaypoints[i],\n\t\t\t\t\torigin: (i === 0) ? initialOrigin : chunckedWaypoints[i-1][chunckedWaypoints[i-1].length - 1],\n\t\t\t\t\tdestination: (i === chunckedWaypoints.length - 1) ? initialDestination : chunckedWaypoints[i+1][0],\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\t// No splitting of the waypoints is requested/needed.\n\t\t// ~> Use one single route\n\t\telse {\n\t\t\troutes.push({\n\t\t\t\twaypoints: initialWaypoints,\n\t\t\t\torigin: initialOrigin,\n\t\t\t\tdestination: initialDestination,\n\t\t\t});\n\t\t}\n\n\t\t// Perform a Directions API Request for each route\n\t\tPromise.all(routes.map((route, index) => {\n\t\t\tlet {\n\t\t\t\torigin,\n\t\t\t\tdestination,\n\t\t\t\twaypoints,\n\t\t\t} = route;\n\n\t\t\tif (origin.latitude && origin.longitude) {\n\t\t\t\torigin = `${origin.latitude},${origin.longitude}`;\n\t\t\t}\n\n\t\t\tif (destination.latitude && destination.longitude) {\n\t\t\t\tdestination = `${destination.latitude},${destination.longitude}`;\n\t\t\t}\n\n\t\t\twaypoints = waypoints\n\t\t\t\t.map(waypoint => (waypoint.latitude && waypoint.longitude) ? `${waypoint.latitude},${waypoint.longitude}` : waypoint)\n\t\t\t\t.join('|');\n\n\t\t\tif (optimizeWaypoints) {\n\t\t\t\twaypoints = `optimize:true|${waypoints}`;\n\t\t\t}\n\n\t\t\tif (index === 0) {\n\t\t\t\tonStart && onStart({\n\t\t\t\t\torigin,\n\t\t\t\t\tdestination,\n\t\t\t\t\twaypoints: initialWaypoints,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn (\n\t\t\t\tthis.fetchRoute(directionsServiceBaseUrl, origin, waypoints, destination, apikey, mode, language, region, precision, timePrecisionString, channel)\n\t\t\t\t\t.then(result => {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t})\n\t\t\t\t\t.catch(errorMessage => {\n\t\t\t\t\t\treturn Promise.reject(errorMessage);\n\t\t\t\t\t})\n\t\t\t);\n\t\t})).then(results => {\n\t\t\t// Combine all Directions API Request results into one\n\t\t\tconst result = results.reduce((acc, { distance, duration, coordinates, fare, legs, waypointOrder }) => {\n\t\t\t\tacc.coordinates = [\n\t\t\t\t\t...acc.coordinates,\n\t\t\t\t\t...coordinates,\n\t\t\t\t];\n\t\t\t\tacc.distance += distance;\n\t\t\t\tacc.duration += duration;\n\t\t\t\tacc.fares = [\n\t\t\t\t\t...acc.fares,\n\t\t\t\t\tfare,\n\t\t\t\t];\n\t\t\t\tacc.legs = legs;\n\t\t\t\tacc.waypointOrder = [\n\t\t\t\t\t...acc.waypointOrder,\n\t\t\t\t\twaypointOrder,\n\t\t\t\t];\n\n\t\t\t\treturn acc;\n\t\t\t}, {\n\t\t\t\tcoordinates: [],\n\t\t\t\tdistance: 0,\n\t\t\t\tduration: 0,\n\t\t\t\tfares: [],\n\t\t\t\tlegs: [],\n\t\t\t\twaypointOrder: [],\n\t\t\t});\n\n\t\t\t// Plot it out and call the onReady callback\n\t\t\tthis.setState({\n\t\t\t\tcoordinates: result.coordinates,\n\t\t\t}, function() {\n\t\t\t\tif (onReady) {\n\t\t\t\t\tonReady(result);\n\t\t\t\t}\n\t\t\t});\n\t\t})\n\t\t\t.catch(errorMessage => {\n\t\t\t\tthis.resetState();\n\t\t\t\tconsole.warn(`MapViewDirections Error: ${errorMessage}`); // eslint-disable-line no-console\n\t\t\t\tonError && onError(errorMessage);\n\t\t\t});\n\t}\n\n\tfetchRoute(directionsServiceBaseUrl, origin, waypoints, destination, apikey, mode, language, region, precision, timePrecision, channel) {\n\n\t\t// Define the URL to call. Only add default parameters to the URL if it's a string.\n\t\tlet url = directionsServiceBaseUrl;\n\t\tif (typeof (directionsServiceBaseUrl) === 'string') {\n\t\t\turl += `?origin=${origin}&waypoints=${waypoints}&destination=${destination}&key=${apikey}&mode=${mode.toLowerCase()}&language=${language}&region=${region}`;\n\t\t\tif(timePrecision){\n\t\t\t\turl+=`&departure_time=${timePrecision}`;\n\t\t\t}\n\t\t\tif(channel){\n\t\t\t\turl+=`&channel=${channel}`;\n\t\t\t}\n\t\t}\n\n\t\treturn fetch(url)\n\t\t\t.then(response => response.json())\n\t\t\t.then(json => {\n\n\t\t\t\tif (json.status !== 'OK') {\n\t\t\t\t\tconst errorMessage = json.error_message || json.status || 'Unknown error';\n\t\t\t\t\treturn Promise.reject(errorMessage);\n\t\t\t\t}\n\n\t\t\t\tif (json.routes.length) {\n\n\t\t\t\t\tconst route = json.routes[0];\n\n\t\t\t\t\treturn Promise.resolve({\n\t\t\t\t\t\tdistance: route.legs.reduce((carry, curr) => {\n\t\t\t\t\t\t\treturn carry + curr.distance.value;\n\t\t\t\t\t\t}, 0) / 1000,\n\t\t\t\t\t\tduration: route.legs.reduce((carry, curr) => {\n\t\t\t\t\t\t\treturn carry + (curr.duration_in_traffic ? curr.duration_in_traffic.value : curr.duration.value);\n\t\t\t\t\t\t}, 0) / 60,\n\t\t\t\t\t\tcoordinates: (\n\t\t\t\t\t\t\t(precision === 'low') ?\n\t\t\t\t\t\t\t\tthis.decode([{polyline: route.overview_polyline}]) :\n\t\t\t\t\t\t\t\troute.legs.reduce((carry, curr) => {\n\t\t\t\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t\t\t\t...carry,\n\t\t\t\t\t\t\t\t\t\t...this.decode(curr.steps),\n\t\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t\t}, [])\n\t\t\t\t\t\t),\n\t\t\t\t\t\tfare: route.fare,\n\t\t\t\t\t\twaypointOrder: route.waypoint_order,\n\t\t\t\t\t\tlegs: route.legs,\n\t\t\t\t\t});\n\n\t\t\t\t} else {\n\t\t\t\t\treturn Promise.reject();\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\treturn Promise.reject(`Error on GMAPS route request: ${err}`);\n\t\t\t});\n\t}\n\n\trender() {\n\t\tconst { coordinates } = this.state;\n\n\t\tif (!coordinates) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst {\n\t\t\torigin, // eslint-disable-line no-unused-vars\n\t\t\twaypoints, // eslint-disable-line no-unused-vars\n\t\t\tsplitWaypoints, // eslint-disable-line no-unused-vars\n\t\t\tdestination, // eslint-disable-line no-unused-vars\n\t\t\tapikey, // eslint-disable-line no-unused-vars\n\t\t\tonReady, // eslint-disable-line no-unused-vars\n\t\t\tonError, // eslint-disable-line no-unused-vars\n\t\t\tmode, // eslint-disable-line no-unused-vars\n\t\t\tlanguage, // eslint-disable-line no-unused-vars\n\t\t\tregion, // eslint-disable-line no-unused-vars\n\t\t\tprecision,  // eslint-disable-line no-unused-vars\n\t\t\t...props\n\t\t} = this.props;\n\n\t\treturn (\n\t\t\t<Polyline coordinates={coordinates} {...props} />\n\t\t);\n\t}\n\n}\n\nMapViewDirections.propTypes = {\n\torigin: PropTypes.oneOfType([\n\t\tPropTypes.string,\n\t\tPropTypes.shape({\n\t\t\tlatitude: PropTypes.number.isRequired,\n\t\t\tlongitude: PropTypes.number.isRequired,\n\t\t}),\n\t]),\n\twaypoints: PropTypes.arrayOf(\n\t\tPropTypes.oneOfType([\n\t\t\tPropTypes.string,\n\t\t\tPropTypes.shape({\n\t\t\t\tlatitude: PropTypes.number.isRequired,\n\t\t\t\tlongitude: PropTypes.number.isRequired,\n\t\t\t}),\n\t\t]),\n\t),\n\tdestination: PropTypes.oneOfType([\n\t\tPropTypes.string,\n\t\tPropTypes.shape({\n\t\t\tlatitude: PropTypes.number.isRequired,\n\t\t\tlongitude: PropTypes.number.isRequired,\n\t\t}),\n\t]),\n\tapikey: PropTypes.string.isRequired,\n\tonStart: PropTypes.func,\n\tonReady: PropTypes.func,\n\tonError: PropTypes.func,\n\tmode: PropTypes.oneOf(['DRIVING', 'BICYCLING', 'TRANSIT', 'WALKING']),\n\tlanguage: PropTypes.string,\n\tresetOnChange: PropTypes.bool,\n\toptimizeWaypoints: PropTypes.bool,\n\tsplitWaypoints: PropTypes.bool,\n\tdirectionsServiceBaseUrl: PropTypes.string,\n\tregion: PropTypes.string,\n\tprecision: PropTypes.oneOf(['high', 'low']),\n\ttimePrecision: PropTypes.oneOf(['now', 'none']),\n\tchannel: PropTypes.string,\n};\n\nexport default MapViewDirections;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}